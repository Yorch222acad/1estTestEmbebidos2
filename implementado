import RPi.GPIO as GPIO # GPIO
import serial # Comunicación Serial
from time import sleep # Retardo
import cv2

# Variables:
BtnBuzzer = 5 # Botón Buzzer
BtnMtr1 = 6 # Botón Motor 1
BtnMtr2 = 13 # Botón Motor 2
MdfDtCy = 19 # Botón Modificar Duty Cycle

droidcam_url = "http://172.20.10.3:4747/video"
cap = cv2.VideoCapture(droidcam_url)

if not cap.isOpened():
    print("Error: No se pudo abrir la cámara.")
    exit()

# Configuración:
GPIO.setmode(GPIO.BCM) # Pines (Modo de numeración BCM)
GPIO.setup(BtnBuzzer, GPIO.IN, pull_up_down=GPIO.PUD_UP) # Buzzer
GPIO.setup(BtnMtr1, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Motor 1
GPIO.setup(BtnMtr2, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Motor 2
GPIO.setup(MdfDtCy, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Modificador Duty Cycle

# Configuración UART:
ser = serial.Serial('/dev/ttyACM0', 9600)
ser.reset_input_buffer()

# Función para ingresar el Duty Cycle por terminal:
def ingDtCy():
    DtCy = int(input("Ingrese el valor del Duty Cycle entre 0 - 100: "))
    while DtCy < 0 or DtCy > 100:
        print("Valor incorrecto")
        DtCy = int(input("Ingrese el valor del Duty Cycle entre 0 - 100: "))
    return DtCy

while True:
    try:
        # Envíar comandos por UART al presionar los botones:
        #------------------------------------------------{ Buzzer:
        if GPIO.input(BtnBuzzer) == GPIO.LOW:
            ser.write(b"buzzer\n")
            print("enviado: buzzer")
            sleep(0.2)
        #}-----------------------------------------------{ Motor 1:
        if GPIO.input(BtnMtr1) == GPIO.LOW:
            ser.write(b"motor1\n")
            print("enviado: motor1")
            sleep(0.2)
        #}-----------------------------------------------{ Motor 2:
        if GPIO.input(BtnMtr2) == GPIO.LOW:
            ser.write(b"motor2\n")
            print("enviado: motor2")
            sleep(0.2)
        #}-----------------------------------------------{ Modificar Duty Cycle:
        if GPIO.input(MdfDtCy) == GPIO.LOW:
            DtCy = ingDtCy()
            mensaje = "DutyCycle " + str(DtCy) + "\n"
            ser.write(mensaje.encode())
            print("enviado:", mensaje.strip())
            sleep(0.2)
        #}--
        # Recibir el Duty Cycle modificado desde Tiva:
        if ser.in_waiting > 0:
            value = ser.readline().decode('utf-8').rstrip()
            print("DutyCycle recibido ", value)

        # Procesar los fotogramas y detectar objetos azules:
        ret, frame = cap.read()
        if not ret:
            print("Error: No se pudo obtener el fotograma.")
            break
        
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # Definir el rango de azul en HSV
        lower_blue = (100, 150, 0)
        upper_blue = (140, 255, 255)
        mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)

        # Aplicar un filtro de suavizado para reducir la variación de tonalidad
        mask_blue = cv2.GaussianBlur(mask_blue, (5, 5), 0)

        # Encontrar los contornos de los objetos azules
        contours, _ = cv2.findContours(mask_blue, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Eliminar contornos pequeños que no sean objetos relevantes
        contours = [cnt for cnt in contours if cv2.contourArea(cnt) > 500]

        # Agrupar objetos cercanos (si los contornos están cerca, los consideramos como un solo objeto)
        blue_objects = 0
        for contour in contours:
            (x, y, w, h) = cv2.boundingRect(contour)
            if w > 30 and h > 30:  # Limita el tamaño mínimo del objeto
                blue_objects += 1

        # Limitar el número de objetos detectados a un máximo de 4
        blue_objects = min(blue_objects, 4)

        # Mostrar el número de objetos azules detectados y enviarlos por UART
        print(f"Objetos azules detectados: {blue_objects}")
        ser.write(str(blue_objects).encode() + b'\n')

        # Mostrar el fotograma con la detección de los objetos azules
        cv2.imshow('Droicam', frame)
        
        # Salir si se presiona 'q'
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break

    except Exception as e:
        print(e)
        break

# Cerrar la conexión UART y liberar la cámara al finalizar
ser.close()
cap.release()
cv2.destroyAllWindows()
